---
title: "WORKSHOP 4"
author: "Maria Bologna"
date: '2023-05-20'
output: html_document
---
# WORKSHOP 4 - Data wrangling in R ####

## 5.3 What is a tibble?

```{r}
library(tidyverse)

#Converting regular data frames in tibbles
iris 
str(iris)
summary(iris)
as_tibble(iris) #*as_tibble()

#Calling new variables
tibble(
  x = 1:5, 
  y = 1, 
  z = x ^ 2 + y)

#Building a dataframe with *data.frame()
#data.frame(c(x = 1:5, y = 1, z = x ^ 2 + y)) --> Error in data.frame(c(x = 1:5, y = 1, z = x^2 + y)) : object 'x' not found
  
#Working with non-syntactic variables
tb <- tibble(
  `:)` = "smile", 
  ` ` = "space",
  `2000` = "number"
)
tb

#Using tribbles (transposed tibbles)
tribble(
  ~x, ~y, ~z,
  #--|--|----
  "a", 2, 3.6,
  "b", 1, 8.5) #*tribble() to help with data entry directly in your script

#Differences with tribbles
tibble(
  a = lubridate::now() + runif(1e3) * 86400,
  b = lubridate::today() + runif(1e3) * 30,
  c = 1:1e3,
  d = runif(1e3),
  e = sample(letters, 1e3, replace = TRUE)) #tibbles only print out the first 10 rows of data plus the type of each column variable next to its name

#install.packages("nycflights13")
library(nycflights13)
nycflights13::flights %>% 
  print(n = 10, width = Inf) #print a designated number of rows with *print(n= number of rows, width= number of columns)

#Options with tibbles
#-":" if more than n rows, print only m rows
#-"options(tibble.print_min = Inf)" to always show all rows
#-"options(tibble.width = Inf)" to print all columns, regardless of the screen width
#-Use Râ€™s built-in viewer with "View()" -> "package?tibble" to check complete list of options 
options(tibble.width = Inf)

#Pulling out a single variable from dataframe
df <- tibble(
  x = runif(5),
  y = rnorm(5))

df$x
df[["x"]]#extract by name
df[[1]] #extract by row position
df[[2,2]] #extract by exact position

#Pipes (*%%)
df %>% .$x
df %>% .[["x"]] #use of "." as placeholder when using pipes

#Recalling a partially matching variable
#df <- tibble(xxx = runif(5, y = rnorm(5))
#df$xx #Warning: Unknown or uninitialised column: `xx`.NULL

#Exercise: why are tibbles preferable?
df <- data.frame(abc = 1, xyz = "a")
df
df$x #call by name
df[, "xyz"] #call by exact position
#Tibbles are preferable as they allow to recall single values from a variable in different ways, which can help when dealing with large or unorganised datasets
```

## 5.4 How can I import data?

```{r}
#heights <- read_csv("data/heights.csv") #import data with *read.csv()

read_csv("a,b,c
1,2,3
4,5,6") #supply the data directly from the script

read_csv("The first line of metadata
  The second line of metadata
  x,y,z
  1,2,3", skip = 2) #to skip over a set number of lines at the top of the dataset -> *skip= n

read_csv("# A comment I want to skip
  x,y,z
  1,2,3", comment = "#") #to drop all lines starting with a certain character -> *comment = "character"

#Solutions for dataframes with nameless columns
read_csv("1,2,3\n4,5,6", col_names = FALSE) #sequentially name columns x1, x2, etc with *col_names= FALSE #shortcut to add a new line: "*\n"

read_csv("1,2,3\n4,5,6", col_names = c("x", "y", "z")) #create a vector to be used as column names with *col_names

read_csv("a,b,c\n1,2,.", na = ".") #to specify "no data" cells in your dataframe, use *na= value used to represent missing data
```

## 5.5 Tidying data  using Tidyr

```{r}
#library(tidyverse)
```

### 5.5.1 Tidy data

```{r}
table1
table2
table3
table4a
table4b

table1 %>%
  mutate(rate = cases / population * 10000) #compute rate per 10000
table1 %>%
  count(year, wt = cases)#compute rate per year

#Visualizing changes over time
library(ggplot2)
ggplot(table1, aes(year, cases)) + 
  geom_line(aes(group = country), colour = "grey50") + 
  geom_point(aes(colour = country))
```

### 5.5.2 Speading and gathering data tables

```{r}
#Tidying a dataset with numerical values as column names
table4a %>% 
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "cases") #to change column names -> *pivot_longer()
table4b %>% 
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "population") #same as above

#Tidying  dataset with an observation scattered across multiple rows
table2 %>%
    pivot_wider(names_from = type, values_from = count) #to unify observations of the same variable from on different rows -> *pivot_wider()
```

### 5.5.3 Separating and uniting data tables

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population")) #to divide columns that contain 2 or more variables at the same time -> *separate(original_column_name, into = c(vector with new column names))

table3 %>% 
  separate(rate, into = c("cases", "population"), sep = "/") #separate variables with a specific character (e.g., /)

table3 %>% 
  separate(rate, into = c("cases", "population"), convert = TRUE) #convert variables listed as characters to better data types -> *convert = TRUE

table3 %>% 
  separate(year, into = c("century", "year"), sep = 2) #split a numerical value in 2+columns after a set number f digits -> *sep= x

table5 %>% 
  unite(new, century, year, sep = "") #unite 2+ columns into one -> *unite(new, x, y, sep="")
```

### 5.5.4 Handling missing values

```{r}
stocks <- tibble(
  year   = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),
  qtr    = c(   1,    2,    3,    4,    2,    3,    4),
  return = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)) #missing values as NA or simply absent

stocks %>% 
  pivot_wider(names_from = year, values_from = return) #make explicit the implicit missing value

stocks %>% 
  pivot_wider(names_from = year, values_from = return) %>% 
  pivot_longer(
    cols = c(`2015`, `2016`), 
    names_to = "year", 
    values_to = "return", 
    values_drop_na = TRUE) #turn implicit missing values into a valid row of data in dataframe -> *values_drop_na= TRUE

stocks %>% 
  complete(year, qtr) #take a set of columns from original dataset, plus fill in explicit NA values where needed -> *complete(x,y)

treatment <- tribble(
  ~ person,           ~ treatment, ~response,
  "Derrick Whitmore", 1,           7,
  NA,                 2,           10,
  NA,                 3,           9,
  "Katherine Burke",  1,           4)
treatment

treatment %>% 
  fill(person) #replace missing values in a dataset with the most recent non-missing value -> *fill(column_with_NAs)
```

## 5.7 Pipes (%%) for more readable flows

```{r}
#Telling a story with R

#Little bunny Foo Foo_Went hopping through the forest_Scooping up the field mice_And bopping them on the head

#library(magrittr)

# foo_foo <- little_bunny()

#1. Create a function for each key verb: hop(), scoop(), bop()
# foo_foo_1 <- hop(foo_foo, through = forest)
# foo_foo_2 <- scoop(foo_foo_1, up = field_mice)
# foo_foo_3 <- bop(foo_foo_2, on = head) #step-by-step construction of each function

#2. Overwrite original objects instead of creating multiple intermediate ones
# foo_foo <- hop(foo_foo, through = forest)
# foo_foo <- scoop(foo_foo, up = field_mice)
# foo_foo <- bop(foo_foo, on = head)

#3. String functions together
# bop(
# scoop(
# hop(foo_foo, through = forest),
# up = field_mice
# ), 
# on = head
# )

#4. Use a pipe
# foo_foo %>%
# hop(through = forest) %>%
# scoop(up = field_mice) %>%
# bop(on = head)

#Classes of functions this pipe won't work for:

#1. Functions already using the current environment
assign("x", 10) #assign() to create a new variable with the iven name in the current environment

"x" %>% assign(100)
x

env <- environment()
"x" %>% assign(100, envir = env) #specify the environment for the %% to work

#2. Functions using lazy evaluation
tryCatch(stop("!"), error = function(e) "An error")

stop("!") %>% 
tryCatch(error = function(e) "An error")
```
